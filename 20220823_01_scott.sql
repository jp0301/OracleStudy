SELECT USER
FROM DUAL;
--==>> SCOTT


-- (20220822_03_scott.sql 저번 시간 이어서 진행)

--※ UNION 은 항상 결과물의 첫 번째 컬럼을 기준으로
--   오름차순 정렬을 수행한다.
--   반면, UNION ALL 은 결합된 순서(구문에서 테이블을 명시한 순서)대로
--   조회한 결과를 있는 그대로 반환한다.
--   이로 인해 UNION 이 부하가 더 크다. (리소스 소모가 더 크다.)
--   또한, UNION은 결과물에 중복된 레코드(행)가 존재할 경우
--   중복을 제거하고 1개 행만 조회된 결과를 반환하게 된다.

--○ 지금까지 주문받은 데이터를 통해
--   제품 별 총 주문량을 조회할 수 있는 쿼리문을 구성한다.

-- 방법 ①
SELECT J.JECODE "제품코드", SUM(J.JUSU) "총주문량"
FROM
(
    SELECT *
    FROM TBL_JUMUN
    UNION ALL
    SELECT *
    FROM TBL_JUMUNBACKUP
) J
GROUP BY J.JECODE;


--○INTERSECT / MINUS (교집합과 차집합)

-- TBL_JUMUNBACKUP 테이블과 TBL_JUMUN 테이블에서
-- 제품코드와 주문수량의 값이 똑같은 행만 추출하고자 한다.

SELECT JECODE, JUSU
FROM TBL_JUMUNBACKUP
MINUS
SELECT JECODE, JUSU
FROM TBL_JUMUN;


SELECT JECODE, JUSU
FROM TBL_JUMUNBACKUP
INTERSECT
SELECT JECODE, JUSU
FROM TBL_JUMUN;
/*
감자깡	20
맛동산	30
빼빼로	10
홈런볼	10
*/


--○ TBL_JUMUNBACKUP 테이블과 TBL_JUMUN 테이블을 대상으로
-- 제품코드와 주문량의 값이 똑같은 행의 정보를
-- 주문번호, 제품코드,  주문량, 주문일자 항목으로 조회한다.


-- 방법 1.
SELECT T2.JUNO "주문번호", T1.JECODE "제품코드", T1.JUSU "주문수량", T2.JUDAY "주문일자"
FROM
(
    SELECT JECODE, JUSU
    FROM TBL_JUMUNBACKUP
    INTERSECT
    SELECT JECODE, JUSU
    FROM TBL_JUMUN
) T1
JOIN
(
    SELECT JUNO, JECODE, JUSU, JUDAY
    FROM TBL_JUMUNBACKUP
    UNION ALL
    SELECT JUNO, JECODE, JUSU, JUDAY
    FROM TBL_JUMUN
) T2
ON T1.JECODE = T2.JECODE
AND T1.JUSU = T2.JUSU;





-- 방법 2.
SELECT T.JUNO "주문번호", T.JECODE "제품코드", T.JUSU "주문량", T.JUDAY "주문일자"
FROM
(
    SELECT JUNO, JECODE, JUSU, JUDAY
    FROM TBL_JUMUNBACKUP
    UNION ALL
    SELECT JUNO, JECODE, JUSU, JUDAY
    FROM TBL_JUMUN
) T
/*
WHERE T.JECODE || T.JUSU = ANY (
    SELECT JECODE || JUSU
    FROM TBL_JUMUNBACKUP
    INTERSECT
    SELECT JECODE || JUSU
    FROM TBL_JUMUN
);
*/
WHERE CONCAT(T.JECODE, T.JUSU) IN (
    SELECT CONCAT(JECODE, JUSU)
    FROM TBL_JUMUNBACKUP
    INTERSECT
    SELECT CONCAT(JECODE, JUSU)
    FROM TBL_JUMUN
);

--------------------------------------------------------------------------------

SELECT D.DEPTNO, D.DNAME, E.ENAME, E.SAL
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO;

SELECT DEPTNO, DNAME, ENAME, SAL
FROM EMP E JOIN DEPT D;
--==>> 에러 발생 ORA-00905: missing keyword

SELECT DEPTNO, DNAME, ENAME, SAL
FROM EMP E NATURAL JOIN DEPT D;
--==>>
/*
10	ACCOUNTING	CLARK	2450
10	ACCOUNTING	KING    	5000
10	ACCOUNTING	MILLER	1300
20	RESEARCH    	JONES	2975
20	RESEARCH	    FORD	    3000
20	RESEARCH    	ADAMS	1100
20	RESEARCH	    SMITH	800
20	RESEARCH	    SCOTT	3000
30	SALES	    WARD	    1250
30	SALES	    TURNER	1500
30	SALES	    ALLEN	1600
30	SALES	    JAMES	950
30	SALES	    BLAKE	2850
30	SALES	    MARTIN	1250
*/

-- (==)
SELECT DEPTNO, DNAME, ENAME, SAL
FROM EMP E JOIN DEPT D
USING(DEPTNO);

--------------------------------------------------------------------------------

--○ TBL_EMP 테이블에서 급여가 가장 많은 사원의
--   사원번호, 사원명, 직종명, 급여 항목을 조회하는 쿼리문을 구성한다.

SELECT *
FROM TBL_EMP;

SELECT EMPNO "사원번호", ENAME "사원명", JOB "직종명", SAL "급여"
FROM TBL_EMP
WHERE SAL = (SELECT MAX(SAL) FROM TBL_EMP);


-- 급여를 가장 많이 받는 사원의 급여
SELECT MAX(SAL)
FROM TBL_EMP;
--==>> 5000

SELECT EMPNO, ENAME, JOB, SAL
FROM TBL_EMP
WHERE 급여가 가장 많이 받는 사원;

SELECT EMPNO, ENAME, JOB, SAL
FROM TBL_EMP
WHERE SAL = 급여가 가장 많이 받는 사원;

SELECT EMPNO, ENAME, JOB, SAL
FROM TBL_EMP
WHERE SAL = (SELECT MAX(SAL) FROM TBL_EMP;);


--『=ANY』

--『=ALL』

SELECT SAL
FROM TBL_EMP;


SELECT EMPNO, ENAME, JOB, SAL
FROM TBL_EMP
WHERE SAL = ANY( SELECT SAL
                FROM TBL_EMP );

SELECT EMPNO, ENAME, JOB, SAL
FROM TBL_EMP
WHERE SAL >= ANY( SELECT SAL
                FROM TBL_EMP );

--==>> 두 구문다 똑같은 결과가 나온다.

SELECT EMPNO, ENAME, JOB, SAL
FROM TBL_EMP
WHERE SAL >= ALL ( SELECT SAL
                FROM TBL_EMP );
--==>> 7839	KING	PRESIDENT	5000
-- MAX 를쓰지않고도 최대 값을 나타낼 수 있음



--○ TBL_EMP 테이블에서 20번 부서에 근무하는 사원들 중
--   급여가 가장 많은 사원의
--   사원번호, 사원명, 직종명, 급여 항목을 조회하는 쿼리문을 구성한다.
SELECT EMPNO, ENAME, JOB, SAL
FROM TBL_EMP
WHERE DEPTNO = 20
  AND SAL =(SELECT MAX(SAL) FROM TBL_EMP WHERE DEPTNO=20);


SELECT EMPNO, ENAME, JOB, SAL
FROM TBL_EMP
WHERE DEPTNO = 20
  AND SAL >= ALL (SELECT SAL FROM TBL_EMP WHERE DEPTNO=20);
--==>>
/*
7902	FORD	ANALYST	3000
7788	SCOTT	ANALYST	3000
*/


--○ TBL_EMP 테이블에서 수당(커미션, COMM)이 가장 많은 사원의
--   사원번호, 사원명, 부서번호, 직종명, 커미션 항목을 조회한다.

SELECT *
FROM TBL_EMP;

SELECT MAX(COMM)
FROM TBL_EMP;

SELECT EMPNO "사원번호", ENAME "사원명", DEPTNO "부서번호", JOB "직종명", COMM "수당"
FROM TBL_EMP
WHERE COMM = (SELECT MAX(COMM) FROM TBL_EMP);
--==>> 7654	MARTIN	30	SALESMAN	    1400

SELECT EMPNO, ENAME, DEPTNO, JOB, COMM
FROM TBL_EMP
WHERE COMM >=ALL(SELECT COMM FROM TBL_EMP);
--==>> 조회 결과 없음

SELECT EMPNO, ENAME, DEPTNO, JOB, COMM
FROM TBL_EMP
WHERE COMM >=ALL(SELECT COMM FROM TBL_EMP);
--==>> NULL 에 의해 제대로 처리되지않음

SELECT EMPNO, ENAME, DEPTNO, JOB, COMM
FROM TBL_EMP
WHERE COMM >=ALL(SELECT NVL(COMM,0) FROM TBL_EMP);
--==>> 7654	MARTIN	30	SALESMAN	    1400

SELECT EMPNO, ENAME, DEPTNO, JOB, COMM
FROM TBL_EMP
WHERE COMM >=ALL(SELECT COMM FROM TBL_EMP WHERE COMM IS NOT NULL);
--==>> 7654	MARTIN	30	SALESMAN	    1400


--○ DISTINCT() 중복 행(레코드)을 제거하는 함수

-- TBL_EMP 테이블에서 관리자로 등록된 사원의
-- 사원번호, 사원명, 직종명을 조회한다.

SELECT *
FROM TBL_EMP;

SELECT EMPNO "사원번호", ENAME "사원명", JOB "직종명"
FROM TBL_EMP
WHERE EMPNO =ANY(SELECT MGR FROM TBL_EMP);

SELECT DISTINCT(MGR)
FROM TBL_EMP;
--==>>
/*
7839
NULL
7782
7698
7902
7566
7788
*/

SELECT EMPNO "사원번호", ENAME "사원명", JOB "직종명"
FROM TBL_EMP
WHERE EMPNO =ANY(SELECT DISTINCT(MGR) FROM TBL_EMP);
--==>> 리소스 소모 ↓

SELECT DISTINCT(JOB)
FROM TBL_EMP;

-------------------------------------------------------------------------------

SELECT *
FROM TBL_SAWON;

--○ TBL_SAWON 테이블 백업(데이터 위주) → 각 테이블 간의 관계나 제약조건 등은 제외한 상태
CREATE TABLE TBL_SAWONBACKUP
AS
SELECT *
FROM TBL_SAWON;
--==>> Table TBL_SAWONBACKUP이(가) 생성되었습니다.
-- TBL_SAWON 테이블의 데이터들만 백업을 수행
-- 즉, 다른 이름의 테이블 형태로 저장해 둔 상황

--○ 데이터 수정
UPDATE TBL_SAWON
SET SANAME = '똘똘이';

COMMIT;

SELECT *
FROM TBL_SAWON;

ROLLBACK;


UPDATE TBL_SAWON
SET SANAME = (  SELECT SANAME
                FROM TBL_SAWONBACKUP 
                WHERE SANO = TBL_SAWON.SANO )
WHERE SANAME = '똘똘이';

SELECT *
FROM TBL_SAWON;


COMMIT;

















